"use strict";(self.webpackChunkhuangmh_blog=self.webpackChunkhuangmh_blog||[]).push([[4909],{3881:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var s=t(8101);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},7895:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"NetWork/websocket-test","title":"Websocket \u5b9e\u6218","description":"\u670d\u52a1\u7aef\u4ee3\u7801","source":"@site/docs/NetWork/websocket-test.mdx","sourceDirName":"NetWork","slug":"/NetWork/websocket-test","permalink":"/docs/NetWork/websocket-test","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"mohan-97","lastUpdatedAt":1726980478000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"WebSocket","permalink":"/docs/NetWork/websocket"},"next":{"title":"\u4e8b\u4ef6\u5faa\u73af","permalink":"/docs/event-loop"}}');var o=t(5105),i=t(3881);const r={},a="Websocket \u5b9e\u6218",c={},l=[{value:"\u670d\u52a1\u7aef\u4ee3\u7801",id:"\u670d\u52a1\u7aef\u4ee3\u7801",level:2},{value:"WebSocket",id:"websocket",level:2},{value:"events",id:"events",level:3},{value:"ReconnectingWebSocket",id:"reconnectingwebsocket",level:3},{value:"HTML \u4ee3\u7801",id:"html-\u4ee3\u7801",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"websocket-\u5b9e\u6218",children:"Websocket \u5b9e\u6218"})}),"\n",(0,o.jsx)(n.h2,{id:"\u670d\u52a1\u7aef\u4ee3\u7801",children:"\u670d\u52a1\u7aef\u4ee3\u7801"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const WebSocket = require("ws");\nconst server = new WebSocket.Server({ port: 3000 });\n\n// \u5f53\u6709\u5ba2\u6237\u7aef\u8fde\u63a5\u65f6\u89e6\u53d1\nserver.on("connection", (socket) => {\n  console.log("Client connected");\n\n  // \u5904\u7406\u6536\u5230\u7684\u6d88\u606f\n  socket.on("message", (data) => {\n    console.log(`Received: ${data}`);\n    // \u5728\u6b64\u5904\u6dfb\u52a0\u5904\u7406\u6d88\u606f\u7684\u903b\u8f91\n  });\n\n  // \u5904\u7406\u8fde\u63a5\u5173\u95ed\n  socket.on("close", () => {\n    console.log("Client disconnected");\n  });\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"websocket",children:"WebSocket"}),"\n",(0,o.jsx)(n.h3,{id:"events",children:"events"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="./ReconnectingWebSocket/events.ts"',children:'export class CloseEvent extends Event {\n  public code: number;\n\n  public reason: string;\n\n  public wasClean = true;\n\n  constructor(code = 1000, reason = "", target?: any) {\n    super("close", target);\n    this.code = code;\n    this.reason = reason;\n  }\n}\n\nexport class ErrorEvent extends Event {\n  public message: string;\n\n  public error: Error;\n\n  constructor(error: Error, target: any) {\n    super("error", target);\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\nexport type WebSocketEventValue = {\n  close: CloseEvent;\n  error: ErrorEvent;\n  message: MessageEvent;\n  open: Event;\n};\n'})}),"\n",(0,o.jsx)(n.h3,{id:"reconnectingwebsocket",children:"ReconnectingWebSocket"}),"\n",(0,o.jsxs)(n.p,{children:["\u53c2\u8003\u5f00\u6e90\u5e93 ",(0,o.jsx)(n.a,{href:"https://github.com/pladaria/reconnecting-websocket",children:"reconnecting-websocket"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="./ReconnectingWebSocket/index.ts"',children:'import type { WebSocketEventValue } from "./events";\nimport { CloseEvent, ErrorEvent } from "./events";\n\nexport type Message = string | ArrayBuffer | Blob | ArrayBufferView;\n\nexport type Options = {\n  debug?: boolean;\n  connectionTimeout?: number;\n  maxRetries?: number;\n  heartbeat?: {\n    message?: Message | (() => Message);\n    delay?: number;\n    timeout?: number;\n  };\n};\n\nconst defaultOptions = {\n  maxReconnectionDelay: 10000,\n  minReconnectionDelay: 1000 + Math.random() * 4000,\n  minUptime: 5000,\n  reconnectionDelayGrowFactor: 1.3,\n  connectionTimeout: 4000,\n  maxRetries: Infinity,\n  maxEnqueuedMessages: Infinity,\n  debug: false,\n};\n\nexport type Listener<T extends keyof WebSocketEventValue> = (\n  value: WebSocketEventValue[T]\n) => void;\n\nexport type ListenersMap = {\n  [key in keyof WebSocketEventValue]: Set<Listener<key>>;\n};\n\nclass ReconnectingWebSocket {\n  private listeners: ListenersMap = {\n    error: new Set(),\n    message: new Set(),\n    open: new Set(),\n    close: new Set(),\n  };\n\n  private ws?: WebSocket;\n\n  private _binaryType: BinaryType = "blob";\n\n  private readonly _url: WebSocket["url"];\n\n  private readonly _protocol?: WebSocket["protocol"];\n\n  private messageQueue: Message[] = [];\n\n  private connectTimeout: ReturnType<Window["setTimeout"]> | undefined;\n\n  private uptimeTimeout: ReturnType<Window["setTimeout"]> | undefined;\n\n  private heartbeatTimeout: ReturnType<Window["setTimeout"]> | undefined;\n\n  private heartbeatInterval: ReturnType<Window["setInterval"]> | undefined;\n\n  private _retryCount = -1;\n\n  private shouldReconnect = true;\n\n  private connectLock = false;\n\n  private closeCalled = false;\n\n  private readonly options: Options;\n\n  constructor(\n    url: WebSocket["url"],\n    protocol?: WebSocket["protocol"],\n    options: Options = {}\n  ) {\n    this._url = url;\n    this._protocol = protocol;\n    this.options = options;\n    this.connect();\n  }\n\n  /**\n   * \u6b63\u5728\u94fe\u63a5\u4e2d\n   */\n  static get CONNECTING() {\n    return 0;\n  }\n\n  /**\n   * \u5df2\u7ecf\u94fe\u63a5\u5e76\u4e14\u53ef\u4ee5\u901a\u8baf\n   */\n  static get OPEN() {\n    return 1;\n  }\n\n  /**\n   * \u8fde\u63a5\u6b63\u5728\u5173\u95ed\n   */\n  static get CLOSING() {\n    return 2;\n  }\n\n  /**\n   * \u8fde\u63a5\u5df2\u5173\u95ed\u6216\u8005\u6ca1\u6709\u94fe\u63a5\u6210\u529f\n   */\n  static get CLOSED() {\n    return 3;\n  }\n\n  /**\n   * \u6b63\u5728\u94fe\u63a5\u4e2d\n   */\n  get CONNECTING() {\n    return ReconnectingWebSocket.CONNECTING;\n  }\n\n  /**\n   * \u5df2\u7ecf\u94fe\u63a5\u5e76\u4e14\u53ef\u4ee5\u901a\u8baf\n   */\n  get OPEN() {\n    return ReconnectingWebSocket.OPEN;\n  }\n\n  /**\n   * \u8fde\u63a5\u6b63\u5728\u5173\u95ed\n   */\n  get CLOSING() {\n    return ReconnectingWebSocket.CLOSING;\n  }\n\n  /**\n   * \u8fde\u63a5\u5df2\u5173\u95ed\u6216\u8005\u6ca1\u6709\u94fe\u63a5\u6210\u529f\n   */\n  get CLOSED() {\n    return ReconnectingWebSocket.CLOSED;\n  }\n\n  get binaryType() {\n    return this.ws ? this.ws.binaryType : this._binaryType;\n  }\n\n  set binaryType(value: BinaryType) {\n    this._binaryType = value;\n    if (this.ws) {\n      this.ws.binaryType = value;\n    }\n  }\n\n  /**\n   * Returns the number or connection retries\n   */\n  get retryCount(): number {\n    return Math.max(this._retryCount, 0);\n  }\n\n  /**\n   * The number of bytes of data that have been queued using calls to send() but not yet\n   * transmitted to the network. This value resets to zero once all queued data has been sent.\n   * This value does not reset to zero when the connection is closed; if you keep calling send(),\n   * this will continue to climb. Read only\n   */\n  get bufferedAmount(): number {\n    const bytes = this.messageQueue.reduce((acc, message) => {\n      if (typeof message === "string") {\n        acc += message.length; // not byte size\n      } else if (message instanceof Blob) {\n        acc += message.size;\n      } else {\n        acc += message.byteLength;\n      }\n      return acc;\n    }, 0);\n    return bytes + (this.ws ? this.ws.bufferedAmount : 0);\n  }\n\n  /**\n   * The extensions selected by the server. This is currently only the empty string or a list of\n   * extensions as negotiated by the connection\n   */\n  get extensions(): string {\n    return this.ws ? this.ws.extensions : "";\n  }\n\n  /**\n   * A string indicating the name of the sub-protocol the server selected;\n   * this will be one of the strings specified in the protocols parameter when creating the\n   * WebSocket object\n   */\n  get protocol(): string {\n    return this.ws ? this.ws.protocol : "";\n  }\n\n  /**\n   * The current state of the connection; this is one of the Ready state constants\n   */\n  get readyState(): number {\n    if (this.ws) {\n      return this.ws.readyState;\n    }\n    return ReconnectingWebSocket.CONNECTING;\n  }\n\n  /**\n   * The URL as resolved by the constructor\n   */\n  get url(): string {\n    return this.ws ? this.ws.url : "";\n  }\n\n  /**\n   * An event listener to be called when the WebSocket connection\'s readyState changes to CLOSED\n   */\n  public onclose: ((event: CloseEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when an error occurs\n   */\n  public onerror: ((event: ErrorEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when a message is received from the server\n   */\n  public onmessage: ((event: MessageEvent) => void) | null = null;\n\n  /**\n   * An event listener to be called when the WebSocket connection\'s readyState changes to OPEN;\n   * this indicates that the connection is ready to send and receive data\n   */\n  public onopen: ((event: Event) => void) | null = null;\n\n  /**\n   *  \u5173\u95edWebSocket\u8fde\u63a5 \u5982\u679cWebSocket\u5df2\u7ecf\u662f\u5173\u95ed\u72b6\u6001 \u4ec0\u4e48\u90fd\u4e0d\u5904\u7406\n   */\n  public close(code = 1000, reason?: string) {\n    this.shouldReconnect = false;\n    this.closeCalled = true;\n    this.clearTimeouts();\n\n    if (!this.ws) {\n      this.debug("close enqueued: no ws instance");\n      return;\n    }\n\n    if (this.ws.readyState === this.CLOSED) {\n      this.debug("close: already closed");\n      return;\n    }\n\n    this.ws.close(code, reason);\n  }\n\n  /**\n   * Closes the WebSocket connection or connection attempt and connects again.\n   * Resets retry counter;\n   */\n  public reconnect(code?: number, reason?: string) {\n    this.shouldReconnect = true;\n    this.closeCalled = false;\n    this._retryCount = -1;\n    if (!this.ws || this.ws.readyState === this.CLOSED) {\n      this.connect();\n    } else {\n      this.disconnect(code, reason);\n      this.connect();\n    }\n  }\n\n  /**\n   * \u5c06\u6307\u5b9a\u6570\u636e\u52a0\u5165\u961f\u5217,\u8fde\u63a5WebSocket\u6210\u529f\u4e4b\u540e\u4f20\u8f93\u5230\u670d\u52a1\u5668\n   */\n  public send(data: Message) {\n    if (this.ws && this.ws.readyState === this.OPEN) {\n      this.debug("send", data);\n      this.ws.send(data);\n    } else {\n      this.debug("enqueue", data);\n      this.messageQueue.push(data);\n    }\n  }\n\n  /**\n   * Register an event handler of a specific event type\n   */\n  public addEventListener<T extends keyof WebSocketEventValue>(\n    type: T,\n    listener: Listener<T>\n  ): void {\n    if (this.listeners[type]) {\n      this.listeners[type].add(listener);\n    }\n  }\n\n  public dispatchEvent<T extends keyof WebSocketEventValue>(\n    type: T,\n    value: WebSocketEventValue[T]\n  ) {\n    const listeners = this.listeners[type];\n    if (listeners) {\n      listeners.forEach((listener) => {\n        listener(value);\n      });\n    }\n  }\n\n  /**\n   *  Removes an event listener\n   */\n  public removeEventListener<T extends keyof WebSocketEventValue>(\n    type: T,\n    listener: Listener<T>\n  ): void {\n    if (this.listeners[type] && this.listeners[type].has(listener)) {\n      this.listeners[type].delete(listener);\n    }\n  }\n\n  private resetHeartbeat = () => {\n    const { heartbeat = {} } = this.options;\n    if (heartbeat.timeout) {\n      clearTimeout(this.heartbeatTimeout);\n      this.heartbeatTimeout = window.setTimeout(() => {\n        this.debug("heartbeat timeout");\n        this.reconnect();\n      }, heartbeat.timeout);\n    }\n  };\n\n  private heartbeat() {\n    const { heartbeat = {} } = this.options;\n    if (heartbeat.delay && heartbeat.message) {\n      this.heartbeatInterval = window.setInterval(() => {\n        const message =\n          typeof heartbeat.message === "function"\n            ? heartbeat.message()\n            : heartbeat.message;\n        this.debug("start heartbeat");\n        this.send(message as Message);\n      }, heartbeat.delay);\n    }\n  }\n\n  private debug(...args: any[]) {\n    if (this.options.debug) {\n      console.log.apply(console, ["RWS>", ...args]);\n    }\n  }\n\n  private getNextDelay() {\n    const {\n      reconnectionDelayGrowFactor,\n      minReconnectionDelay,\n      maxReconnectionDelay,\n    } = defaultOptions;\n    let delay = 0;\n    if (this._retryCount > 0) {\n      delay =\n        minReconnectionDelay *\n        Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);\n      if (delay > maxReconnectionDelay) {\n        delay = maxReconnectionDelay;\n      }\n    }\n    this.debug("next delay", delay);\n    return delay;\n  }\n\n  private wait(time: number): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(resolve, time);\n    });\n  }\n\n  private handleMessage = (event: MessageEvent) => {\n    this.debug("message event", event);\n\n    this.resetHeartbeat();\n\n    if (this.onmessage) {\n      this.onmessage(event);\n    }\n\n    this.dispatchEvent("message", event);\n  };\n\n  private connect = () => {\n    if (this.connectLock || !this.shouldReconnect) {\n      return;\n    }\n    this.connectLock = true;\n\n    const {\n      connectionTimeout = defaultOptions.connectionTimeout,\n      maxRetries = defaultOptions.maxRetries,\n    } = this.options;\n\n    if (this._retryCount >= maxRetries) {\n      this.debug("max retries reached", this._retryCount, ">=", maxRetries);\n      return;\n    }\n\n    this._retryCount = this._retryCount + 1;\n\n    this.debug("connect", this._retryCount);\n\n    this.removeListener();\n\n    this.wait(this.getNextDelay()).then(() => {\n      if (this.closeCalled) {\n        return;\n      }\n\n      this.debug("connect", { url: this._url, protocol: this._protocol });\n\n      this.ws = new WebSocket(this._url, this._protocol);\n      this.ws!.binaryType = this._binaryType;\n      this.connectLock = false;\n\n      this.addListeners();\n\n      // \u8fde\u63a5\u8d85\u65f6\u4e4b\u540e\u81ea\u52a8\u91cd\u8fde\n      this.connectTimeout = window.setTimeout(() => {\n        this.handleTimeout();\n      }, connectionTimeout);\n    });\n  };\n\n  private handleTimeout = () => {\n    this.debug("timeout event");\n    this.handleError(new ErrorEvent(new Error("TIMEOUT"), this));\n  };\n\n  private disconnect(code = 1000, reason?: string) {\n    this.clearTimeouts();\n\n    if (!this.ws) {\n      return;\n    }\n\n    this.removeListener();\n\n    try {\n      this.ws.close();\n      this.handleClose(new CloseEvent(code, reason, this));\n    } catch {\n      // do nothing\n    }\n  }\n\n  private acceptOpen() {\n    this.debug("accept open");\n    this._retryCount = 0;\n  }\n\n  private handleOpen = (event: Event) => {\n    if (!this.ws) {\n      return;\n    }\n\n    this.debug("open event");\n\n    this.uptimeTimeout = window.setTimeout(\n      () => this.acceptOpen(),\n      defaultOptions.minUptime\n    );\n\n    this.heartbeat();\n\n    this.resetHeartbeat();\n\n    // \u8fde\u63a5\u6210\u529f\u4e4b\u540e\u53d6\u6d88\u5b9a\u65f6\u5668\n    clearTimeout(this.connectTimeout);\n\n    this.ws.binaryType = this._binaryType;\n\n    if (this.messageQueue.length > 0) {\n      // send enqueued messages (messages sent before websocket open event)\n      this.messageQueue.forEach((message) => this.ws?.send(message));\n      this.messageQueue = [];\n    }\n\n    if (this.onopen) {\n      this.onopen(event);\n    }\n\n    this.dispatchEvent("open", event);\n  };\n\n  private handleError = (event: ErrorEvent) => {\n    this.debug("error event", event.message);\n    this.disconnect(\n      undefined,\n      event.message === "TIMEOUT" ? "timeout" : undefined\n    );\n\n    if (this.onerror) {\n      this.onerror(event);\n    }\n\n    this.debug("exec error listeners");\n    this.dispatchEvent("error", event);\n\n    this.connect();\n  };\n\n  private handleClose = (event: CloseEvent) => {\n    this.debug("close event");\n    this.clearTimeouts();\n\n    if (this.shouldReconnect) {\n      this.connect();\n    }\n\n    if (this.onclose) {\n      this.onclose(event);\n    }\n\n    this.dispatchEvent("close", event);\n  };\n\n  private addListeners = () => {\n    if (!this.ws) {\n      return;\n    }\n    this.debug("addEventListener");\n    this.ws.addEventListener("open", this.handleOpen);\n    this.ws.addEventListener("message", this.handleMessage);\n    this.ws.addEventListener("close", this.handleClose);\n    // @ts-ignore\n    this.ws.addEventListener("error", this.handleError);\n  };\n\n  private removeListener = () => {\n    if (!this.ws) {\n      return;\n    }\n    this.debug("removeEventListener");\n    this.ws.removeEventListener("open", this.handleOpen);\n    this.ws.removeEventListener("message", this.handleMessage);\n    this.ws.removeEventListener("close", this.handleClose);\n    // @ts-ignore\n    this.ws.removeEventListener("error", this.handleError);\n  };\n\n  private clearTimeouts() {\n    clearTimeout(this.connectTimeout);\n    clearTimeout(this.uptimeTimeout);\n    clearInterval(this.heartbeatInterval);\n    clearTimeout(this.heartbeatTimeout);\n  }\n}\n\nexport default ReconnectingWebSocket;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"html-\u4ee3\u7801",children:"HTML \u4ee3\u7801"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'const App: FC = () => {\n  const websocket = useMemo(() => {\n    return new ReconnectingWebSocket("ws://localhost:3000", undefined, {\n      debug: true,\n    });\n  }, []);\n\n  return (\n    <div>\n      <button>\u53d1\u9001\u6d88\u606f</button>\n      <button\n        onClick={() => {\n          websocket.close();\n        }}\n      >\n        \u5173\u95edWebSocket\n      </button>\n    </div>\n  );\n};\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);