"use strict";(self.webpackChunkhuangmh_blog=self.webpackChunkhuangmh_blog||[]).push([[4909],{4956:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"NetWork/websocket-test","title":"Websocket \u5b9e\u6218","description":"\u670d\u52a1\u7aef\u4ee3\u7801","source":"@site/docs/NetWork/websocket-test.mdx","sourceDirName":"NetWork","slug":"/NetWork/websocket-test","permalink":"/docs/NetWork/websocket-test","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"mohan-97","lastUpdatedAt":1726980478000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"WebSocket","permalink":"/docs/NetWork/websocket"},"next":{"title":"\u4e8b\u4ef6\u5faa\u73af","permalink":"/docs/event-loop"}}');var s=r(3274),o=r(8438);const i={},a="Websocket \u5b9e\u6218",c={},l=[{value:"\u670d\u52a1\u7aef\u4ee3\u7801",id:"\u670d\u52a1\u7aef\u4ee3\u7801",level:2},{value:"WebSocket",id:"websocket",level:2},{value:"events",id:"events",level:3},{value:"ReconnectingWebSocket",id:"reconnectingwebsocket",level:3},{value:"HTML \u4ee3\u7801",id:"html-\u4ee3\u7801",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"websocket-\u5b9e\u6218",children:"Websocket \u5b9e\u6218"})}),"\n",(0,s.jsx)(n.h2,{id:"\u670d\u52a1\u7aef\u4ee3\u7801",children:"\u670d\u52a1\u7aef\u4ee3\u7801"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const WebSocket = require("ws");\r\nconst server = new WebSocket.Server({ port: 3000 });\r\n\r\n// \u5f53\u6709\u5ba2\u6237\u7aef\u8fde\u63a5\u65f6\u89e6\u53d1\r\nserver.on("connection", (socket) => {\r\n  console.log("Client connected");\r\n\r\n  // \u5904\u7406\u6536\u5230\u7684\u6d88\u606f\r\n  socket.on("message", (data) => {\r\n    console.log(`Received: ${data}`);\r\n    // \u5728\u6b64\u5904\u6dfb\u52a0\u5904\u7406\u6d88\u606f\u7684\u903b\u8f91\r\n  });\r\n\r\n  // \u5904\u7406\u8fde\u63a5\u5173\u95ed\r\n  socket.on("close", () => {\r\n    console.log("Client disconnected");\r\n  });\r\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"websocket",children:"WebSocket"}),"\n",(0,s.jsx)(n.h3,{id:"events",children:"events"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="./ReconnectingWebSocket/events.ts"',children:'export class CloseEvent extends Event {\r\n  public code: number;\r\n\r\n  public reason: string;\r\n\r\n  public wasClean = true;\r\n\r\n  constructor(code = 1000, reason = "", target?: any) {\r\n    super("close", target);\r\n    this.code = code;\r\n    this.reason = reason;\r\n  }\r\n}\r\n\r\nexport class ErrorEvent extends Event {\r\n  public message: string;\r\n\r\n  public error: Error;\r\n\r\n  constructor(error: Error, target: any) {\r\n    super("error", target);\r\n    this.message = error.message;\r\n    this.error = error;\r\n  }\r\n}\r\n\r\nexport type WebSocketEventValue = {\r\n  close: CloseEvent;\r\n  error: ErrorEvent;\r\n  message: MessageEvent;\r\n  open: Event;\r\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"reconnectingwebsocket",children:"ReconnectingWebSocket"}),"\n",(0,s.jsxs)(n.p,{children:["\u53c2\u8003\u5f00\u6e90\u5e93 ",(0,s.jsx)(n.a,{href:"https://github.com/pladaria/reconnecting-websocket",children:"reconnecting-websocket"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",metastring:'title="./ReconnectingWebSocket/index.ts"',children:'import type { WebSocketEventValue } from "./events";\r\nimport { CloseEvent, ErrorEvent } from "./events";\r\n\r\nexport type Message = string | ArrayBuffer | Blob | ArrayBufferView;\r\n\r\nexport type Options = {\r\n  debug?: boolean;\r\n  connectionTimeout?: number;\r\n  maxRetries?: number;\r\n  heartbeat?: {\r\n    message?: Message | (() => Message);\r\n    delay?: number;\r\n    timeout?: number;\r\n  };\r\n};\r\n\r\nconst defaultOptions = {\r\n  maxReconnectionDelay: 10000,\r\n  minReconnectionDelay: 1000 + Math.random() * 4000,\r\n  minUptime: 5000,\r\n  reconnectionDelayGrowFactor: 1.3,\r\n  connectionTimeout: 4000,\r\n  maxRetries: Infinity,\r\n  maxEnqueuedMessages: Infinity,\r\n  debug: false,\r\n};\r\n\r\nexport type Listener<T extends keyof WebSocketEventValue> = (\r\n  value: WebSocketEventValue[T]\r\n) => void;\r\n\r\nexport type ListenersMap = {\r\n  [key in keyof WebSocketEventValue]: Set<Listener<key>>;\r\n};\r\n\r\nclass ReconnectingWebSocket {\r\n  private listeners: ListenersMap = {\r\n    error: new Set(),\r\n    message: new Set(),\r\n    open: new Set(),\r\n    close: new Set(),\r\n  };\r\n\r\n  private ws?: WebSocket;\r\n\r\n  private _binaryType: BinaryType = "blob";\r\n\r\n  private readonly _url: WebSocket["url"];\r\n\r\n  private readonly _protocol?: WebSocket["protocol"];\r\n\r\n  private messageQueue: Message[] = [];\r\n\r\n  private connectTimeout: ReturnType<Window["setTimeout"]> | undefined;\r\n\r\n  private uptimeTimeout: ReturnType<Window["setTimeout"]> | undefined;\r\n\r\n  private heartbeatTimeout: ReturnType<Window["setTimeout"]> | undefined;\r\n\r\n  private heartbeatInterval: ReturnType<Window["setInterval"]> | undefined;\r\n\r\n  private _retryCount = -1;\r\n\r\n  private shouldReconnect = true;\r\n\r\n  private connectLock = false;\r\n\r\n  private closeCalled = false;\r\n\r\n  private readonly options: Options;\r\n\r\n  constructor(\r\n    url: WebSocket["url"],\r\n    protocol?: WebSocket["protocol"],\r\n    options: Options = {}\r\n  ) {\r\n    this._url = url;\r\n    this._protocol = protocol;\r\n    this.options = options;\r\n    this.connect();\r\n  }\r\n\r\n  /**\r\n   * \u6b63\u5728\u94fe\u63a5\u4e2d\r\n   */\r\n  static get CONNECTING() {\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * \u5df2\u7ecf\u94fe\u63a5\u5e76\u4e14\u53ef\u4ee5\u901a\u8baf\r\n   */\r\n  static get OPEN() {\r\n    return 1;\r\n  }\r\n\r\n  /**\r\n   * \u8fde\u63a5\u6b63\u5728\u5173\u95ed\r\n   */\r\n  static get CLOSING() {\r\n    return 2;\r\n  }\r\n\r\n  /**\r\n   * \u8fde\u63a5\u5df2\u5173\u95ed\u6216\u8005\u6ca1\u6709\u94fe\u63a5\u6210\u529f\r\n   */\r\n  static get CLOSED() {\r\n    return 3;\r\n  }\r\n\r\n  /**\r\n   * \u6b63\u5728\u94fe\u63a5\u4e2d\r\n   */\r\n  get CONNECTING() {\r\n    return ReconnectingWebSocket.CONNECTING;\r\n  }\r\n\r\n  /**\r\n   * \u5df2\u7ecf\u94fe\u63a5\u5e76\u4e14\u53ef\u4ee5\u901a\u8baf\r\n   */\r\n  get OPEN() {\r\n    return ReconnectingWebSocket.OPEN;\r\n  }\r\n\r\n  /**\r\n   * \u8fde\u63a5\u6b63\u5728\u5173\u95ed\r\n   */\r\n  get CLOSING() {\r\n    return ReconnectingWebSocket.CLOSING;\r\n  }\r\n\r\n  /**\r\n   * \u8fde\u63a5\u5df2\u5173\u95ed\u6216\u8005\u6ca1\u6709\u94fe\u63a5\u6210\u529f\r\n   */\r\n  get CLOSED() {\r\n    return ReconnectingWebSocket.CLOSED;\r\n  }\r\n\r\n  get binaryType() {\r\n    return this.ws ? this.ws.binaryType : this._binaryType;\r\n  }\r\n\r\n  set binaryType(value: BinaryType) {\r\n    this._binaryType = value;\r\n    if (this.ws) {\r\n      this.ws.binaryType = value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the number or connection retries\r\n   */\r\n  get retryCount(): number {\r\n    return Math.max(this._retryCount, 0);\r\n  }\r\n\r\n  /**\r\n   * The number of bytes of data that have been queued using calls to send() but not yet\r\n   * transmitted to the network. This value resets to zero once all queued data has been sent.\r\n   * This value does not reset to zero when the connection is closed; if you keep calling send(),\r\n   * this will continue to climb. Read only\r\n   */\r\n  get bufferedAmount(): number {\r\n    const bytes = this.messageQueue.reduce((acc, message) => {\r\n      if (typeof message === "string") {\r\n        acc += message.length; // not byte size\r\n      } else if (message instanceof Blob) {\r\n        acc += message.size;\r\n      } else {\r\n        acc += message.byteLength;\r\n      }\r\n      return acc;\r\n    }, 0);\r\n    return bytes + (this.ws ? this.ws.bufferedAmount : 0);\r\n  }\r\n\r\n  /**\r\n   * The extensions selected by the server. This is currently only the empty string or a list of\r\n   * extensions as negotiated by the connection\r\n   */\r\n  get extensions(): string {\r\n    return this.ws ? this.ws.extensions : "";\r\n  }\r\n\r\n  /**\r\n   * A string indicating the name of the sub-protocol the server selected;\r\n   * this will be one of the strings specified in the protocols parameter when creating the\r\n   * WebSocket object\r\n   */\r\n  get protocol(): string {\r\n    return this.ws ? this.ws.protocol : "";\r\n  }\r\n\r\n  /**\r\n   * The current state of the connection; this is one of the Ready state constants\r\n   */\r\n  get readyState(): number {\r\n    if (this.ws) {\r\n      return this.ws.readyState;\r\n    }\r\n    return ReconnectingWebSocket.CONNECTING;\r\n  }\r\n\r\n  /**\r\n   * The URL as resolved by the constructor\r\n   */\r\n  get url(): string {\r\n    return this.ws ? this.ws.url : "";\r\n  }\r\n\r\n  /**\r\n   * An event listener to be called when the WebSocket connection\'s readyState changes to CLOSED\r\n   */\r\n  public onclose: ((event: CloseEvent) => void) | null = null;\r\n\r\n  /**\r\n   * An event listener to be called when an error occurs\r\n   */\r\n  public onerror: ((event: ErrorEvent) => void) | null = null;\r\n\r\n  /**\r\n   * An event listener to be called when a message is received from the server\r\n   */\r\n  public onmessage: ((event: MessageEvent) => void) | null = null;\r\n\r\n  /**\r\n   * An event listener to be called when the WebSocket connection\'s readyState changes to OPEN;\r\n   * this indicates that the connection is ready to send and receive data\r\n   */\r\n  public onopen: ((event: Event) => void) | null = null;\r\n\r\n  /**\r\n   *  \u5173\u95edWebSocket\u8fde\u63a5 \u5982\u679cWebSocket\u5df2\u7ecf\u662f\u5173\u95ed\u72b6\u6001 \u4ec0\u4e48\u90fd\u4e0d\u5904\u7406\r\n   */\r\n  public close(code = 1000, reason?: string) {\r\n    this.shouldReconnect = false;\r\n    this.closeCalled = true;\r\n    this.clearTimeouts();\r\n\r\n    if (!this.ws) {\r\n      this.debug("close enqueued: no ws instance");\r\n      return;\r\n    }\r\n\r\n    if (this.ws.readyState === this.CLOSED) {\r\n      this.debug("close: already closed");\r\n      return;\r\n    }\r\n\r\n    this.ws.close(code, reason);\r\n  }\r\n\r\n  /**\r\n   * Closes the WebSocket connection or connection attempt and connects again.\r\n   * Resets retry counter;\r\n   */\r\n  public reconnect(code?: number, reason?: string) {\r\n    this.shouldReconnect = true;\r\n    this.closeCalled = false;\r\n    this._retryCount = -1;\r\n    if (!this.ws || this.ws.readyState === this.CLOSED) {\r\n      this.connect();\r\n    } else {\r\n      this.disconnect(code, reason);\r\n      this.connect();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * \u5c06\u6307\u5b9a\u6570\u636e\u52a0\u5165\u961f\u5217,\u8fde\u63a5WebSocket\u6210\u529f\u4e4b\u540e\u4f20\u8f93\u5230\u670d\u52a1\u5668\r\n   */\r\n  public send(data: Message) {\r\n    if (this.ws && this.ws.readyState === this.OPEN) {\r\n      this.debug("send", data);\r\n      this.ws.send(data);\r\n    } else {\r\n      this.debug("enqueue", data);\r\n      this.messageQueue.push(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register an event handler of a specific event type\r\n   */\r\n  public addEventListener<T extends keyof WebSocketEventValue>(\r\n    type: T,\r\n    listener: Listener<T>\r\n  ): void {\r\n    if (this.listeners[type]) {\r\n      this.listeners[type].add(listener);\r\n    }\r\n  }\r\n\r\n  public dispatchEvent<T extends keyof WebSocketEventValue>(\r\n    type: T,\r\n    value: WebSocketEventValue[T]\r\n  ) {\r\n    const listeners = this.listeners[type];\r\n    if (listeners) {\r\n      listeners.forEach((listener) => {\r\n        listener(value);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  Removes an event listener\r\n   */\r\n  public removeEventListener<T extends keyof WebSocketEventValue>(\r\n    type: T,\r\n    listener: Listener<T>\r\n  ): void {\r\n    if (this.listeners[type] && this.listeners[type].has(listener)) {\r\n      this.listeners[type].delete(listener);\r\n    }\r\n  }\r\n\r\n  private resetHeartbeat = () => {\r\n    const { heartbeat = {} } = this.options;\r\n    if (heartbeat.timeout) {\r\n      clearTimeout(this.heartbeatTimeout);\r\n      this.heartbeatTimeout = window.setTimeout(() => {\r\n        this.debug("heartbeat timeout");\r\n        this.reconnect();\r\n      }, heartbeat.timeout);\r\n    }\r\n  };\r\n\r\n  private heartbeat() {\r\n    const { heartbeat = {} } = this.options;\r\n    if (heartbeat.delay && heartbeat.message) {\r\n      this.heartbeatInterval = window.setInterval(() => {\r\n        const message =\r\n          typeof heartbeat.message === "function"\r\n            ? heartbeat.message()\r\n            : heartbeat.message;\r\n        this.debug("start heartbeat");\r\n        this.send(message as Message);\r\n      }, heartbeat.delay);\r\n    }\r\n  }\r\n\r\n  private debug(...args: any[]) {\r\n    if (this.options.debug) {\r\n      console.log.apply(console, ["RWS>", ...args]);\r\n    }\r\n  }\r\n\r\n  private getNextDelay() {\r\n    const {\r\n      reconnectionDelayGrowFactor,\r\n      minReconnectionDelay,\r\n      maxReconnectionDelay,\r\n    } = defaultOptions;\r\n    let delay = 0;\r\n    if (this._retryCount > 0) {\r\n      delay =\r\n        minReconnectionDelay *\r\n        Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);\r\n      if (delay > maxReconnectionDelay) {\r\n        delay = maxReconnectionDelay;\r\n      }\r\n    }\r\n    this.debug("next delay", delay);\r\n    return delay;\r\n  }\r\n\r\n  private wait(time: number): Promise<void> {\r\n    return new Promise((resolve) => {\r\n      setTimeout(resolve, time);\r\n    });\r\n  }\r\n\r\n  private handleMessage = (event: MessageEvent) => {\r\n    this.debug("message event", event);\r\n\r\n    this.resetHeartbeat();\r\n\r\n    if (this.onmessage) {\r\n      this.onmessage(event);\r\n    }\r\n\r\n    this.dispatchEvent("message", event);\r\n  };\r\n\r\n  private connect = () => {\r\n    if (this.connectLock || !this.shouldReconnect) {\r\n      return;\r\n    }\r\n    this.connectLock = true;\r\n\r\n    const {\r\n      connectionTimeout = defaultOptions.connectionTimeout,\r\n      maxRetries = defaultOptions.maxRetries,\r\n    } = this.options;\r\n\r\n    if (this._retryCount >= maxRetries) {\r\n      this.debug("max retries reached", this._retryCount, ">=", maxRetries);\r\n      return;\r\n    }\r\n\r\n    this._retryCount = this._retryCount + 1;\r\n\r\n    this.debug("connect", this._retryCount);\r\n\r\n    this.removeListener();\r\n\r\n    this.wait(this.getNextDelay()).then(() => {\r\n      if (this.closeCalled) {\r\n        return;\r\n      }\r\n\r\n      this.debug("connect", { url: this._url, protocol: this._protocol });\r\n\r\n      this.ws = new WebSocket(this._url, this._protocol);\r\n      this.ws!.binaryType = this._binaryType;\r\n      this.connectLock = false;\r\n\r\n      this.addListeners();\r\n\r\n      // \u8fde\u63a5\u8d85\u65f6\u4e4b\u540e\u81ea\u52a8\u91cd\u8fde\r\n      this.connectTimeout = window.setTimeout(() => {\r\n        this.handleTimeout();\r\n      }, connectionTimeout);\r\n    });\r\n  };\r\n\r\n  private handleTimeout = () => {\r\n    this.debug("timeout event");\r\n    this.handleError(new ErrorEvent(new Error("TIMEOUT"), this));\r\n  };\r\n\r\n  private disconnect(code = 1000, reason?: string) {\r\n    this.clearTimeouts();\r\n\r\n    if (!this.ws) {\r\n      return;\r\n    }\r\n\r\n    this.removeListener();\r\n\r\n    try {\r\n      this.ws.close();\r\n      this.handleClose(new CloseEvent(code, reason, this));\r\n    } catch {\r\n      // do nothing\r\n    }\r\n  }\r\n\r\n  private acceptOpen() {\r\n    this.debug("accept open");\r\n    this._retryCount = 0;\r\n  }\r\n\r\n  private handleOpen = (event: Event) => {\r\n    if (!this.ws) {\r\n      return;\r\n    }\r\n\r\n    this.debug("open event");\r\n\r\n    this.uptimeTimeout = window.setTimeout(\r\n      () => this.acceptOpen(),\r\n      defaultOptions.minUptime\r\n    );\r\n\r\n    this.heartbeat();\r\n\r\n    this.resetHeartbeat();\r\n\r\n    // \u8fde\u63a5\u6210\u529f\u4e4b\u540e\u53d6\u6d88\u5b9a\u65f6\u5668\r\n    clearTimeout(this.connectTimeout);\r\n\r\n    this.ws.binaryType = this._binaryType;\r\n\r\n    if (this.messageQueue.length > 0) {\r\n      // send enqueued messages (messages sent before websocket open event)\r\n      this.messageQueue.forEach((message) => this.ws?.send(message));\r\n      this.messageQueue = [];\r\n    }\r\n\r\n    if (this.onopen) {\r\n      this.onopen(event);\r\n    }\r\n\r\n    this.dispatchEvent("open", event);\r\n  };\r\n\r\n  private handleError = (event: ErrorEvent) => {\r\n    this.debug("error event", event.message);\r\n    this.disconnect(\r\n      undefined,\r\n      event.message === "TIMEOUT" ? "timeout" : undefined\r\n    );\r\n\r\n    if (this.onerror) {\r\n      this.onerror(event);\r\n    }\r\n\r\n    this.debug("exec error listeners");\r\n    this.dispatchEvent("error", event);\r\n\r\n    this.connect();\r\n  };\r\n\r\n  private handleClose = (event: CloseEvent) => {\r\n    this.debug("close event");\r\n    this.clearTimeouts();\r\n\r\n    if (this.shouldReconnect) {\r\n      this.connect();\r\n    }\r\n\r\n    if (this.onclose) {\r\n      this.onclose(event);\r\n    }\r\n\r\n    this.dispatchEvent("close", event);\r\n  };\r\n\r\n  private addListeners = () => {\r\n    if (!this.ws) {\r\n      return;\r\n    }\r\n    this.debug("addEventListener");\r\n    this.ws.addEventListener("open", this.handleOpen);\r\n    this.ws.addEventListener("message", this.handleMessage);\r\n    this.ws.addEventListener("close", this.handleClose);\r\n    // @ts-ignore\r\n    this.ws.addEventListener("error", this.handleError);\r\n  };\r\n\r\n  private removeListener = () => {\r\n    if (!this.ws) {\r\n      return;\r\n    }\r\n    this.debug("removeEventListener");\r\n    this.ws.removeEventListener("open", this.handleOpen);\r\n    this.ws.removeEventListener("message", this.handleMessage);\r\n    this.ws.removeEventListener("close", this.handleClose);\r\n    // @ts-ignore\r\n    this.ws.removeEventListener("error", this.handleError);\r\n  };\r\n\r\n  private clearTimeouts() {\r\n    clearTimeout(this.connectTimeout);\r\n    clearTimeout(this.uptimeTimeout);\r\n    clearInterval(this.heartbeatInterval);\r\n    clearTimeout(this.heartbeatTimeout);\r\n  }\r\n}\r\n\r\nexport default ReconnectingWebSocket;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"html-\u4ee3\u7801",children:"HTML \u4ee3\u7801"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const App: FC = () => {\r\n  const websocket = useMemo(() => {\r\n    return new ReconnectingWebSocket("ws://localhost:3000", undefined, {\r\n      debug: true,\r\n    });\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <button>\u53d1\u9001\u6d88\u606f</button>\r\n      <button\r\n        onClick={() => {\r\n          websocket.close();\r\n        }}\r\n      >\r\n        \u5173\u95edWebSocket\r\n      </button>\r\n    </div>\r\n  );\r\n};\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8438:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(9474);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);