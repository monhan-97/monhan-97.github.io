# JWT

## 什么是 JWT

**JWT** 简称 `JSON WEB TOKEN` 本质就是个字符串, 它解决了在互联网环境下，‌ 如何安全、‌ 统一地传递用户身份验证信息的问题。

**JWT** 通过提供一个令牌格式，‌ 使得客户端和服务器之间可以方便地进行身份验证和授权。这个令牌可以存储在多个位置(`cookie`,`localStorage`),这个令牌一般放在 `HTTP` 请求头里面进行传输到服务端。

**JWT** 的灵活性和便捷性在于,它不依赖于特定的存储机制或传输方式,使得身份验证信息可以在不同的客户端和服务器之间无缝传递。‌

## JWT 的使用场景

- **身份验证(Authentication)**:

  **JWT** 可以被用作用户登录的身份验证凭证。当用户成功登录后，服务端可以生成一个包含用户信息的 **JWT** ,并将其返回给客户端。以后，客户端在每次请求时都会携带这个 **JWT** ,服务端通过验证 **JWT** 的签名来确认用户的身份。

- **授权(Authorization)**:

  在用户登录后，服务端可以生成包含用户角色、权限等信息的 **JWT**,并在用户每次请求时进行验证。通过解析 **JWT**, 中的声明信息，服务端可以判断用户是否有权限执行特定的操作或访问特定的资源。

- **信息交换(Information Exchange)**:

  由于 **JWT** 的声明信息可以被加密，因此可以安全地在用户和服务器之间传递信息。这在分布式系统中非常有用，因为可以确保信息在各个环节中的安全传递。

- **单点登录(Single Sign-On)**:

  **JWT** 可以被用于支持单点登录，使得用户在多个应用之间只需要登录一次即可使用多个应用，从而提高用户体验。

## JWT 令牌的组成

JWT 令牌由三个部分组成:**头部(Header)**、**负载(Payload)** 和**签名(Signature)**

- header : 令牌头部,记录了整个令牌的`类型`和`签名算法`。
- payload : 令牌负荷,包含了一些有关实体(通常是用户)的信息以及其他元数据。
- signature : 令牌签名,按照头部固定的签名算法对整个令牌进行签名。

它们组合的完整格式:`header.payload.signature`

### 头部 Header

这个是令牌头部,记录了整个令牌的`类型`和`签名算法`。

```javascript
{
    "alg":"HS256",
    "typ":"JWT"
}
```

- alg:signature 部分使用的签名算法,通常可以取两个值。
  - HS256: 一种对称加密算法,使用同一个密钥对 `signature` 部分进行加密和解密
  - RS256:一种非对称加密算法,使用私钥签名,公钥验证。
- typ:整个令牌的类型,一般都是`JWT`。

通常 `header` 部分也会采用 `Base64` 编码。

```javascript
window.btoa(
  JSON.stringify({
    alg: "HS256",
    typ: "JWT",
  })
);

// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

### 负载 Payload

**JWT** 的载荷也称为声明信息，包含了一些有关实体（通常是用户）的信息以及其他元数据。通常包括以下几种声明：

- **Registered Claim:** 这些声明是预定义的，包括 iss(发行者)、sub(主题) aud(受众)、exp(过期时间)、nbf(生效时间)、iat(发布时间) 和 jti(JWT ID)等。

- **Public Claims:** 这些声明可以自定义，但需要注意避免与注册声明的名称冲突。

- **Private Claims:** 这些声明是保留给特定的应用程序使用的，不会与其他应用程序冲突。

通常 `payload` 部分也会采用 `Base64` 编码。

### 签名 Signature

签名`signature`的生成,是对前面两个部分(Header,Payload)的编码结果。按照头部指定的方式进行加密。它用于验证**JWT**的真实性和完整性。

根据头部中指定的算法，使用密钥（对于对称加密）或公钥（对于非对称加密）对头部和负载进行签名，确保数据未被篡改
